print(replace_file_content_tool(file_path='src/pages/AIQuestions.tsx', old_content='import { useQuery } from "convex/react";', new_content='import { useQuery, useMutation } from "convex/react";'))
print(replace_file_content_tool(file_path='src/pages/MockTests.tsx', old_content='import { useQuery } from "convex/react";', new_content='import { useQuery, useMutation } from "convex/react";'))
print(read_file_tool(file_path='src/pages/PYQSets.tsx'))
print(replace_file_content_tool(file_path='src/convex/student.ts', old_content='''    // Check for Monthly Starter Plan (₹99)
    if (subscription.amount === 99) {
      // Define limits for Monthly Starter
      const limits = {
        mock: 25,
        pyq: 20,
        ai: 25
      };

      const limit = limits[args.testType as keyof typeof limits] || 0;
      
      // Count sets used
      let setsUsed = 0;
      
      if (args.testType === "mock") {
        const attempts = await ctx.db
          .query("weeklyTestAttempts")
          .withIndex("by_user", (q) => q.eq("userId", user._id))
          .collect();
        // Count unique tests attempted
        const uniqueTests = new Set(attempts.map(a => a.weeklyTestId));
        setsUsed = uniqueTests.size;
      } else if (args.testType === "pyq") {
        const sessions = await ctx.db
          .query("testSessions")
          .withIndex("by_user", (q) => q.eq("userId", user._id))
          .filter(q => q.eq(q.field("testType"), "pyq"))
          .collect();
        // Count unique sets (year + examName)
        // This is an approximation, ideally we track unique sets directly
        setsUsed = sessions.length; 
      } else if (args.testType === "ai") {
        const sessions = await ctx.db
          .query("testSessions")
          .withIndex("by_user", (q) => q.eq("userId", user._id))
          .filter(q => q.eq(q.field("testType"), "ai"))
          .collect();
        setsUsed = sessions.length;
      }

      return {
        canAccess: setsUsed < limit,
        reason: "monthly_starter_limit_reached",
        setsUsed,
        setLimit: limit
      };
    }''', new_content='''    // Check for Monthly Starter Plan (₹99)
    if (subscription.amount === 99) {
      // Define limits for Monthly Starter
      const limits = {
        mock: 25,
        pyq: 20,
        ai: 25
      };

      const limit = limits[args.testType as keyof typeof limits] || 0;
      
      // Count sets used
      let setsUsed = 0;
      
      if (args.testType === "mock") {
        const attempts = await ctx.db
          .query("weeklyTestAttempts")
          .withIndex("by_user", (q) => q.eq("userId", user._id))
          .collect();
        // Count unique tests attempted
        const uniqueTests = new Set(attempts.map(a => a.weeklyTestId));
        setsUsed = uniqueTests.size;
      } else if (args.testType === "pyq") {
        const sessions = await ctx.db
          .query("testSessions")
          .withIndex("by_user", (q) => q.eq("userId", user._id))
          .filter(q => q.eq(q.field("testType"), "pyq"))
          .collect();
        // Count unique sets (year + examName)
        // This is an approximation, ideally we track unique sets directly
        setsUsed = sessions.length; 
      } else if (args.testType === "ai") {
        const sessions = await ctx.db
          .query("testSessions")
          .withIndex("by_user", (q) => q.eq("userId", user._id))
          .filter(q => q.eq(q.field("testType"), "ai"))
          .collect();
        setsUsed = sessions.length;
      }

      const adUnlockCount = (await ctx.db
        .query("adUnlockedTests")
        .withIndex("by_user_and_type", (q) =>
          q.eq("userId", user._id).eq("testType", args.testType)
        )
        .collect()
      ).length;

      const totalAllowedSets = limit + adUnlockCount;

      return {
        canAccess: setsUsed < totalAllowedSets,
        reason: "monthly_starter_limit_reached",
        setsUsed,
        setLimit: totalAllowedSets,
      };
    }'''))
print(execute_command_tool(command='npx convex dev --once && npx tsc -b --noEmit'))
