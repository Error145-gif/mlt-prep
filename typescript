// src/convex/student.ts
// ... (keep existing code above canAccessTestType)

export const canAccessTestType = query({
  args: { testType: v.string() },
  handler: async (ctx, args) => {
    const user = await getCurrentUser(ctx);
    if (!user) {
      return { canAccess: false, reason: "not_authenticated" };
    }

    const subscription = await ctx.db
      .query("subscriptions")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .filter((q) => q.eq(q.field("status"), "active"))
      .first();

    const hasActiveSubscription = subscription && subscription.endDate > Date.now();

    // Determine plan limits (in sets)
    let mockSetLimit = 1; // Default for free trial
    let pyqSetLimit = 1;
    let aiSetLimit = 1;
    let isMonthlyStarterPlan = false;

    if (hasActiveSubscription) {
      if (subscription.amount === 99 || subscription.planName.includes("Monthly Starter")) {
        isMonthlyStarterPlan = true;
        mockSetLimit = 25;
        pyqSetLimit = 20;
        aiSetLimit = 25;
      } else {
        // Unlimited for higher plans
        mockSetLimit = 9999;
        pyqSetLimit = 9999;
        aiSetLimit = 9999;
      }
    }

    let limit = 0;
    if (args.testType === "mock") {
      limit = mockSetLimit;
    } else if (args.testType === "pyq") {
      limit = pyqSetLimit;
    } else if (args.testType === "ai") {
      limit = aiSetLimit;
    }

    // Count unique sets completed by the user for this testType
    const completedSets = await ctx.db
      .query("testSessions")
      .withIndex("by_user_and_type_and_status", (q) =>
        q.eq("userId", user._id).eq("testType", args.testType).eq("status", "completed")
      )
      .collect();

    const uniqueCompletedSetNumbers = new Set(
      completedSets.map((session) => session.setNumber)
    ).size;

    // Count ad-unlocked tests for this type
    const adUnlockedTests = await ctx.db
      .query("adUnlockedTests")
      .withIndex("by_user_and_type", (q) => q.eq("userId", user._id).eq("testType", args.testType))
      .collect();

    const adUnlockedSetNumbers = new Set(
      adUnlockedTests.map((adUnlock) => adUnlock.testSetNumber)
    );
    
    // Free Trial Logic
    if (!hasActiveSubscription) {
      if (uniqueCompletedSetNumbers > 0) { // If user completed any free test
        return { canAccess: false, reason: "free_trial_used", setLimit: limit, setsUsed: uniqueCompletedSetNumbers };
      }
      return { canAccess: true, reason: "free_trial", setLimit: limit, setsUsed: uniqueCompletedSetNumbers };
    }

    // Paid Subscription Logic
    if (isMonthlyStarterPlan) {
      // If subscription limit is reached based on completed tests
      if (uniqueCompletedSetNumbers >= limit) {
        // If there are any ad-unlocked tests, overall access is still possible for individual tests
        if (adUnlockedSetNumbers.size > 0) {
          return {
            canAccess: true, // Overall access is true because ad unlocks are available
            reason: "monthly_starter_limit_reached_ad_available",
            setLimit: limit, // Still return the subscription limit
            setsUsed: uniqueCompletedSetNumbers,
            adUnlockedTestsCount: adUnlockedSetNumbers.size,
          };
        }
        // Subscription limit reached, and no ad unlocks available
        return {
          canAccess: false,
          reason: "monthly_starter_limit_reached",
          setLimit: limit, // Still return the subscription limit
          setsUsed: uniqueCompletedSetNumbers,
        };
      }
      // Subscription limit not reached yet
      return { canAccess: true, reason: "paid_subscription", setLimit: limit, setsUsed: uniqueCompletedSetNumbers };
    }

    // Unlimited plans
    return { canAccess: true, reason: "paid_subscription", setLimit: limit, setsUsed: uniqueCompletedSetNumbers };
  },
});
// ... (keep existing code below canAccessTestType)
